/**
  * Copyright (C) 2008 Sonatype Inc.
  * Sonatype Inc, licenses this file to you under the Apache License,
  * Version 2.0 (the "License"); you may not use this file except in
  * compliance with the License.  You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  * KIND, either express or implied.  See the License for the
  * specific language governing permissions and limitations
  * under the License.
  */
package org.sonatype.plexus.maven.plugin;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.factory.ArtifactFactory;
import org.apache.maven.artifact.repository.ArtifactRepository;
import org.apache.maven.artifact.resolver.ArtifactNotFoundException;
import org.apache.maven.artifact.resolver.ArtifactResolutionException;
import org.apache.maven.artifact.resolver.ArtifactResolver;
import org.apache.maven.plugin.Mojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;
import org.codehaus.plexus.util.StringUtils;
import org.codehaus.plexus.util.cli.CommandLineException;
import org.codehaus.plexus.util.cli.Commandline;
import org.codehaus.plexus.util.cli.StreamConsumer;
import org.codehaus.plexus.util.cli.StreamPumper;
import org.sonatype.appbooter.PlexusContainerHost;
import org.sonatype.appbooter.ctl.ControlConnectionException;
import org.sonatype.appbooter.ctl.ControllerClient;
import org.sonatype.plexus.classworlds.io.ClassworldsConfWriter;
import org.sonatype.plexus.classworlds.io.ClassworldsIOException;
import org.sonatype.plexus.classworlds.model.ClassworldsAppConfiguration;
import org.sonatype.plexus.classworlds.model.ClassworldsRealmConfiguration;
import org.sonatype.plexus.classworlds.validator.ClassworldsModelValidator;
import org.sonatype.plexus.classworlds.validator.ClassworldsValidationResult;

import java.io.File;
import java.io.IOException;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;

/**
 * Start a Plexus application, and optionally wait for Ctl-C to shut it down. Otherwise,
 * complete the mojo's execution with the application still running (useful for
 * integration testing). The application is started in a separate process, with
 * a control port listening for administrative commands.
 *
 * @author Jason van Zyl
 * @author John Casey
 * @execute phase="test"
 * @goal run
 * @requiresDependencyResolution test
 */
public class PlexusRunMojo
    implements Mojo/*, Service*/
{
    // ------------------------------------------------------------------------
    // Maven Parameters
    // ------------------------------------------------------------------------

    /**
     * If true, do NOT wait for CTL-C to terminate the application, just start
     * it and return. Future calls to plx:stop or direct use of the
     * {@link ControllerClient} API can manage the application once started.
     *
     * @parameter default-value="false" expression="${plx.disableBlocking}"
     */
    private boolean disableBlocking;

    /**
     * Turns on debug mode, which uses the debugJavaCmd to start the plexus
     * application instead of the normal javaCmd.
     *
     * @parameter default-value="false" expression="${plx.debug}"
     */
    private boolean debug;

    /**
     * Output diagnostic information for the command line and classworlds configuration
     * file generated by this mojo in order to start the application.
     *
     * @parameter default-value="false" expression="${plx.debugOutput}"
     */
    private boolean debugOutput;

    /**
     * Java command used to start the Plexus application under normal (non-debug)
     * circumstances.
     *
     * @parameter default-value="java"
     */
    private String javaCmd;

    /**
     * Substitutes the given port into the expression '@DEBUG_PORT@' in your debugJavaCmd.
     *
     * @parameter default-value="5005" expression="${plx.debugPort}"
     */
    private int debugPort;

    /**
     * Substitutes 'y' or 'n' into the expression '@DEBUG_SUSPEND@' in your debugJavaCmd.
     *
     * @parameter default-value="true" expression="${plx.debugSuspend}"
     */
    private boolean debugSuspend;

    /**
     * Java command used to start the Plexus application into debugging mode, which
     * is meant to allow attachment of a remote application debugger via JPDA, etc.
     *
     * @parameter default-value="java -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,suspend=@DEBUG_SUSPEND@,address=@DEBUG_PORT@ -Djava.compiler=NONE"
     */
    private String debugJavaCmd;

    /**
     * The class containing the main method that will be used to start up the Plexus
     * container to initialize the application.
     * <br/>
     * CAUTION! Be sure you understand the ramifications before changing this!
     *
     * @parameter default-value="org.sonatype.appbooter.PlexusContainerHost"
     */
    private String launcherClass;

    /**
     * System properties passed on to the new java process.
     *
     * @parameter
     */
    private Map<String, String> systemProperties;

    /** @parameter expression="${project}" */
    private MavenProject project;

    /** @parameter expression="${configuration}" default-value="${basedir}/src/main/plexus/plexus.xml" */
    private File configuration;

    /** @parameter expression="${basedir}" */
    private File basedir;

    /**
     * @parameter default-value="${project.build.directory}"
     */
    private File targetDir;

    /** @parameter expression="${project.build.outputDirectory}" */
    private File classes;

    /** @parameter expression="${project.build.testOutputDirectory}" */
    private File testClasses;

    /** @parameter default-value="false" */
    private boolean includeTestClasspath;

    /**
     * Artifact coordinate containing the platform classes for the application.
     * These should include a plexus container, along with the launcherClass.
     * <br/>
     * Default is org.sonatype.appbooter.plexus-platforms:plexus-platform-base:1.0-SNAPSHOT
     *
     * @parameter
     */
    private PlatformArtifact platformArtifact = PlatformArtifact.DEFAULT;

    /**
     * List of class paths to prepend to the classworlds configuration.
     *
     * @parameter
     */
    private List<String> prependClasspaths;

    /**
     * @component
     */
    private ArtifactResolver resolver;

    /**
     * @component
     */
    private ArtifactFactory factory;

    /**
     * @parameter default-value="${localRepository}"
     * @readonly
     */
    private ArtifactRepository localRepository;

    /**
     * @parameter default-value="${project.remoteArtifactRepositories}"
     * @readonly
     */
    private List<ArtifactRepository> remoteRepositories;

    /**
     * Uses DEFAULT_CONTROL_PORT from {@link PlexusContainerHost} by default.
     * <br/>
     * This is the port used to administer the remote application. If you execute
     * with disableBlocking == true, you may need to know this port to use the
     * {@link ControllerClient} API directly (from integration-test JUnit code,
     * for instance).
     *
     * @parameter expression="${plx.controlPort}" default-value="-1"
     */
    private int controlPort;

    private ControllerClient controlClient;

//    private ControllerClient controlServiceClient;

    private Log log;

//    private int exitCode = 0;
//
//    private boolean shouldShutdown = false;
//
//    private boolean isStopped = false;
//
//    private Thread managementThread;

    StreamPumper outPumper = null;

    StreamPumper errPumper = null;

    @SuppressWarnings( "unchecked" )
    public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        //Get the control objects for the 2 running threads we will be handling, the first (controlClient) is our access to the PlexusContainerHost
        //NOTE: currently only PlexusContainerHost is supported as launcher class, as there are a number of areas throughout where it is directly
        //referenced.
        //The second object we get (controlServiceClient) is for this object the plx:run mojo, strictly used for the ShutdownHook to be able to stop plx:run if necessary
        if ( !configuration.exists() )
        {
            throw new MojoFailureException(
                                            "There is no plexus.xml file present. Make sure you are in a directory where a Plexus application lives." );
        }

        try
        {
            controlClient = new ControllerClient( controlPort > -1 ? controlPort : PlexusContainerHost.DEFAULT_CONTROL_PORT );
        }
        catch ( UnknownHostException e )
        {
            throw new MojoExecutionException(
                                              "Remote-control client for plexus application cannot resolve localhost.",
                                              e );
        }

        //In case plx:stop isn't run at some point later, and this is a non-blocking instance, here is the backup plan
        getLog().info( "Enabling shutdown hook for remote plexus application." );
        Runtime.getRuntime().addShutdownHook( new Thread( new ShutdownHook() ) );

        Commandline cli = buildCommandLine();

        executeCommandLine( cli );

        getLog().info( "Sleeping 5 seconds for application to start." );
        try
        {
            Thread.sleep( 5000 );
        }
        catch ( InterruptedException e )
        {
        }

        if ( !disableBlocking )
        {
            try
            {
                controlClient.shutdownOnClose();
            }
            catch ( ControlConnectionException e )
            {
                throw new MojoExecutionException( "Failed to send shutdown-on-close command to application host. You may need to terminate the application manually.", e );
            }
            catch ( IOException e )
            {
                throw new MojoExecutionException( "Failed to send shutdown-on-close command to application host. You may need to terminate the application manually.", e );
            }

            try
            {
                synchronized ( this )
                {
                    try
                    {
                        wait();
                    }
                    catch ( InterruptedException e )
                    {
                    }
                }
            }
            finally
            {
                stopStreamPumps();
                controlClient.close();
            }
        }

    }

    protected Commandline buildCommandLine()
        throws MojoFailureException, MojoExecutionException
    {
        File platformFile = getPlatformFile();
        ClassworldsAppConfiguration config = buildConfig();
        File classworldsConf = writeConfig( config );

        Commandline cli = new Commandline();

        String cmd = javaCmd;
        if ( debug )
        {
            cmd = debugJavaCmd;
            cmd = StringUtils.replace( cmd, "@DEBUG_PORT@", String.valueOf( debugPort ) );
            cmd = StringUtils.replace( cmd, "@DEBUG_SUSPEND@", ( debugSuspend ? "y" : "n" ) );
        }

        String[] baseCommand = cmd.split( " " );

        cli.setExecutable( baseCommand[0] );
        if ( baseCommand.length > 1 )
        {
            for ( int i = 1; i < baseCommand.length; i++ )
            {
                cli.createArg().setLine( baseCommand[i] );
            }
        }

        cli.createArg()
           .setLine( "-Dclassworlds.conf=\'" + classworldsConf.getAbsolutePath() + "\'" );
        cli.createArg().setLine( "-jar" );
        cli.createArg().setLine( "\'" + platformFile.getAbsolutePath() + "\'" );

        if ( outputDebugMessages() )
        {
            getLog().info( "Executing:\n\n" + StringUtils.join( cli.getCommandline(), " " ) );
        }
        return cli;
    }

    @SuppressWarnings( "unchecked" )
    private File getPlatformFile()
        throws MojoFailureException, MojoExecutionException
    {
        String platformVersion = platformArtifact.getVersion();
        Map<String, Artifact> managedVersionMap = project.getManagedVersionMap();
        if ( managedVersionMap != null )
        {
            Artifact managed = managedVersionMap.get( platformArtifact.getManagementKey() );
            if ( managed != null )
            {
                platformVersion = managed.getVersion();
            }
        }
        Artifact platform = factory.createArtifact( platformArtifact.getGroupId(),
                                                    platformArtifact.getArtifactId(),
                                                    platformVersion,
                                                    null,
                                                    platformArtifact.getType() );
        try
        {
            resolver.resolve( platform, remoteRepositories, localRepository );
        }
        catch ( ArtifactResolutionException e )
        {
            throw new MojoExecutionException( "Failed to resolve platform artifact: "
                                              + platform.getId(), e );
        }
        catch ( ArtifactNotFoundException e )
        {
            throw new MojoExecutionException( "Cannot find platform artifact: " + platform.getId(),
                                              e );
        }

        File platformFile = platform.getFile();
        if ( outputDebugMessages() )
        {
            getLog().info( "Using plexus platform: " + platformArtifact + "\nFile: "
                           + platformFile.getAbsolutePath() );
        }
        return platformFile;
    }

    private File writeConfig( ClassworldsAppConfiguration config )
        throws MojoExecutionException
    {
        File classworldsConf = new File( targetDir, "classworlds.conf" );

        try
        {
            new ClassworldsConfWriter().write( classworldsConf, config );
        }
        catch ( ClassworldsIOException e )
        {
            throw new MojoExecutionException( e.getMessage(), e );
        }

        if ( outputDebugMessages() )
        {
            getLog().info( "Saving Classworlds configuration at: "
                           + classworldsConf.getAbsolutePath() );
        }

        return classworldsConf;
    }

    protected boolean outputDebugMessages()
    {
        return debug || debugOutput || getLog().isDebugEnabled();
    }

    private ClassworldsAppConfiguration buildConfig()
        throws MojoExecutionException
    {
        ClassworldsRealmConfiguration rootRealmConfig = new ClassworldsRealmConfiguration( "plexus" );

        if ( prependClasspaths != null && !prependClasspaths.isEmpty() )
        {
            rootRealmConfig.addLoadPatterns( prependClasspaths );
        }

        if ( includeTestClasspath )
        {
            rootRealmConfig.addLoadPattern( testClasses.getAbsolutePath() );
        }

        rootRealmConfig.addLoadPattern( classes.getAbsolutePath() );

        rootRealmConfig.addLoadPatterns( getDependencyPaths() );

        ClassworldsAppConfiguration config = new ClassworldsAppConfiguration();

        config.setMainClass( launcherClass );
        config.addRealmConfiguration( rootRealmConfig );
        config.setMainRealm( rootRealmConfig.getRealmId() );

        Map<String, String> sysProps = new HashMap<String, String>();

        // allow the override of the basedir...
        sysProps.put( "basedir", basedir.getAbsolutePath() );

        if ( systemProperties != null && !systemProperties.isEmpty() )
        {
            getLog().info( "Using system properties:\n\n" + systemProperties );
            sysProps.putAll( systemProperties );
        }

        sysProps.put( PlexusContainerHost.CONFIGURATION_FILE_PROPERTY,
                      configuration.getAbsolutePath() );
        sysProps.put( PlexusContainerHost.ENABLE_CONTROL_SOCKET, "true" );

        config.setSystemProperties( sysProps );

        ClassworldsValidationResult vr = new ClassworldsModelValidator().validate( config );
        if ( vr.hasErrors() )
        {
            throw new MojoExecutionException( vr.render() );
        }

        return config;
    }

    @SuppressWarnings( "unchecked" )
    private LinkedHashSet<String> getDependencyPaths()
    {
        LinkedHashSet<String> paths = new LinkedHashSet<String>();

        if ( includeTestClasspath )
        {
            for ( Artifact artifact : (List<Artifact>) project.getTestArtifacts() )
            {
                paths.add( artifact.getFile().getAbsolutePath() );
            }
        }
        else
        {
            // NOTE: We're including compile, runtime, and provided scopes here
            // since the platform may be assumed to be provided by the distro base,
            // where this might only be executing the app that runs inside that base.
            for ( Artifact artifact : (List<Artifact>) project.getTestArtifacts() )
            {
                if ( Artifact.SCOPE_COMPILE.equals( artifact.getScope() )
                     || Artifact.SCOPE_RUNTIME.equals( artifact.getScope() )
                     || Artifact.SCOPE_PROVIDED.equals( artifact.getScope() ) )
                {
                    paths.add( artifact.getFile().getAbsolutePath() );
                }
            }
        }

        return paths;
    }

    private void stopStreamPumps()
    {
        if ( outPumper != null )
        {
            outPumper.close();
        }

        if ( errPumper != null )
        {
            errPumper.close();
        }
    }

    protected final class ShutdownHook
        implements Runnable
    {
        protected ShutdownHook()
        {
        }

        public void run()
        {
            //If not closed normally...
            if ( controlClient != null && controlClient.isOpen() )
            {
                System.out.println( "ShutdownHook is closing the client connection." );
                //Do it now
                controlClient.close();
            }
        }
    }

    public Log getLog()
    {
        return log;
    }

    public void setLog( Log log )
    {
        this.log = log;
    }

    private void executeCommandLine( Commandline cli )
        throws MojoExecutionException
    {
        StreamConsumer out = new StreamConsumer()
        {
            public void consumeLine( String line )
            {
                getLog().info( line );
            }
        };

        Process p = null;

        try
        {
            p = cli.execute();

            outPumper = new StreamPumper( p.getInputStream(), out );
            errPumper = new StreamPumper( p.getErrorStream(), out );

            outPumper.setPriority( Thread.MIN_PRIORITY + 1 );
            errPumper.setPriority( Thread.MIN_PRIORITY + 1 );

            outPumper.start();
            errPumper.start();
        }
        catch ( CommandLineException e )
        {
            throw new MojoExecutionException( "Failed to execute plexus application: "
                                              + e.getMessage(), e );
        }
    }

}
